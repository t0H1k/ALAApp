//
//  DataStore.swift
//  ALAApp
//
//  Created by Айтолкун Анарбекова on 26/10/22.
//


class DataStore {
    
    let chapter = [
        "Жизненный цикл UIViewController",
        "Жизненный цикл приложения",
        "Функции Высшего Порядка"
    ]
    
    let subChapter = [
        [
            "viewDidLoad",
            "viewWillApear",
            "viewWillLayoutSubviews",
            "updateViewConstraints",
            "viewDidLayoutSubviews",
            "viewDidApear",
            "viewWillTransitionToSize",
            "didReceiveMemoryWarning",
            "viewWillDisapear",
            "viewDidDisapear",
            "awakeFromNib",
            "loadView"
        ],
        
        [
            "didFinishLaunchingWithOptions",
            "applicationWillResignActive",
            "applicationDidEnterBackground",
            "applicationWillEnterForeground",
            "applicationDidBecomeActive",
            "applicationWillTerminate",
        ],
        [
            "14.1 Метод map(_:)",
            "14.2 Метод mapValues(_:)",
            "14.3 Метод flatMap(_:)",
            "14.4 Метод compactMap(_:)",
            "14.5 Метод filter(_:)",
            "14.6 Метод reduce(_:_:)",
            "14.7 Метод zip(_:_:)",
            "14.8 Оператор guard для опционалов",
            "14.9 Оператор отложенных действий defer"
        ]
    ]
    
    let content = [
        [
            "В данном методе можно выполнить большинство настроек дляконтроллера. Он вызывается ровно один раз, когда контроллер представления загружается в память.Здесь можно инициализировать переменные и объекты, которые должны жить на протяжении всего жизненного цикла вью.На этом этапе границы вью еще не установлены и мы не можем обращаться к значениям геометрии (высоте, ширине и прочим параметрам)",
            "Перед появлением вью на экране мы получаем уведомление об этом от метода viewWillApear. Этот метод вызывается перед тем как view будет добавлена в текущую иерархию, перед отработкой какой бы то ни было анимации.",
            "Если вы не используете Auto Layout, то viewWillLayoutSubviews является тем самым местом, где вы можете изменить размеры subview и их положение. Вызов super. viewWillLayoutSubviews не требуется",
            "В остальных случаях, для того, что бы изменить значения констрейнтов (например, при повороте экрана), используется метод updateViewConstraints. В конце переопределенного метода нужно обязательно вызывать super.updateViewConstraints и именно в конце. Вызов данного метода происходит перед вызовом viewWillLayoutSubviews.",
            "На этом этапе жизненного цикла можно быть уверенным, что View корректно выставила положения для всех своих потомков. В этом методе можно сохранять последние состояния каких либо элементов, например положение Scroll View или выделение ячейки в Table View. По умолчанию данный метод не делает ни чего, так что вызывать super.viewDidLayoutSubviews() не нужно",
            "После расстановки границ, вью появляется на экране и мы получаем уведомление об этом от метода viewDidApear. Данный метод является финальным метод в цепочке и может быть вызван не один раз в течении жизненного цикла вью контроллера, например если из контроллера открыть Modal View Controller. В этом случае наш контроллер не будет выгружен из памяти, но само вью, тем не менее будет закрыто.",
            "Обработка поворота экрана обрабатывается автоматически, и задается в настройках приложения. Однако если нужно самостоятельно обработать анимацию при повороте, то можно можно воспользоваться методом viewWillTransitionToSize",
            "В случае нехватки памяти срабатывает метод didReceiveMemoryWarning и в нем можно попробовать обнулить объекты, которые не используются.",
            "Когда вью уходит с экрана, то перед этим срабатывает метод viewWillDisapear. Здесь обычно коммитят изменения, убирают first responder статус, ставят на паузу выполняемые действия, отменяют ориентацию/стиль статус бара если ее меняли в 4 viewWillAppear и т.д. Можно почистить данные, обнулить кеш и все в таком духе. Метод требует вызов super.viewWillDisappear",
            "Оповещение о том, что View было удалено из иерархии. Область применения схожа с viewWillDisappear, здесь так же удаляют ненужные данные, ставят на паузу плеер. Нужно просто понимать, что этот метод вызовется после анимации удаления View, а предыдущий перед. Также нужно вызывать super.viewDidDisappear",
            "Отдельно нужно сказать про метод — awakeFromNib. На самом деле он не является частью ViewController Lifecycle, но нужно понимать что он вызывается сразу после инициализации, перед подготовкой перехода у контроллера, который задан с помощью storyboard.",
            "метод loadView, который используется при ручной инициализации View. Если не использовать данный метод, то контроллер делает это автоматически."
        ],
        
        [
            "Это самый первый метод, который срабатывает после загрузки приложения и в нем делают первичную настройку параметров самого приложения: - Определяется интерфейс в зависимости от типа устройства на котором запущено приложение - Определяется стартовый вью контроллер - Инициализация пуш уведомлений - Загрузка первичных данных из базы Так же тут можно изменять глобальный интерфейс всего приложения. Например, можно изменить цвет навигейшин бара и его заголовка не для отдельно взятого экрана, а во всем приложении целиком.",
            "Вызов данного метода происходит перед переходом приложения в фоновый режим. В фоновый режим приложение переходит при сворачивании, при входящем звонке, при переходе на другое приложение. - Останавливаем любимые активные задачи - Ставим на паузу игры и проигрывание видео",
            "Вызов данного метода происходит после перехода приложения в фоновый режим. Метод используется для освобождения общих ресурсов, аннулирования таймеров и сохранения сведений о состоянии приложения для последующего его восстановления. Тут следует отключить обновления пользовательского интерфейса, а так же необходимо избегать использования OpenGL. Для приложений, способных поддерживать работу в фоновом режими, этот метод вызывается вместо метода applicationWillTerminate, который в свою очередь вызывается при завершении работы приложения.",
            "Вызов данного метода происходит при возврате приложения из фонового режима. Используется для отмены изменений, выполненных при входе в фоновый режим.",
            "Перемещает приложение из неактивного состояния в активное. Переход происходит при запуске приложения, а так же при возврате приложения из фонового режима. Приложения также могут вернуться в активное состояние, если пользователь игнорирует прерывание (например, входящий телефонный звонок или SMS-сообщение), которое временно отправило приложение в неактивное состояние. Этот метод следует использовать для перезапуска всех задач, которые были приостановлены (или еще не запущены), пока приложение было неактивно. Если приложение ранее находилось в фоновом режиме, его также можно использовать для обновления пользовательского интерфейса приложения",
            "Вызывается перед тем, как приложение будет выгружено из памяти. 7 Этот метод следует использовать для очистки приложения и высвобождения общих ресурсов, сохранение пользовательских данных и аннулирование таймеров. Для приложений, поддерживающих фоновое выполнение, этот метод обычно не вызывается при выходе пользователя из приложения, поскольку в этом случае приложение просто перемещается в фоновый режим. Однако этот метод может быть вызван в ситуациях, когда приложение работает в фоновом режиме (не приостановлено), и система должна прекратить его по какой-либо причине",
        ],
        [
            "14.1 Метод map(_:) позволяет применить переданное в него замыкание для каждого элемента коллекции. В результате его выполнения возвращается новая последовательность, тип элементов которой может отличаться от типа исходных элементов.",
            "14.2 Метод mapValues(_:) позволяет обработать значения каждого элемента словаря, при этом ключи элементов останутся в исходном состоянии.",
            "14.3 Метод flatMap(_:) отличается от map(_:) тем, что всегда возвращает плоский одно- мерный массив. Так, пример, приведенный в листинге 14.4, но с использованием flatMap(_:), вернет одномерный массив.",
            "14.4 Метод compactMap(_:) позволяет произвести те же действия, что и map(_:), разница лишь в реакции на ситуацию, когда преобразование не может быть произведено.",
            "14.5 Метод filter(_:) используется, когда требуется отфильтровать элементы коллекции по определенному правилу.",
            "14.6 Метод reduce(_:_:) позволяет объединить все элементы коллекции в одно значение в соответствии с переданным замыканием. Помимо самих элементов метод принимает первоначальное значение, которое служит для выполнения операции с первым элементом коллекции.",
            "14.7 Функция zip(_:_:) предназначена для формирования последовательности пар значений, каждая из которых составлена из элементов двух базовых последовательностей. Другими словами, если у вас есть две последовательности и вам нужно попарно брать их элементы, группировать и складывать в новую последовательность, то эта функция как раз то, что нужно. Сначала вы берете первые элементы каждой последовательности, группируете их, потом берете вторые элементы, и т. д.",
            "14.8 Оператор guard проверяет, возможно ли провести операцию опционального связывания, и в случае отрицательного результата выполняет код тела оператора, где с помощью return досрочно завершается работа функции. Если опциональное связывание успешно завершается, то тело guard игнорируется и выполняет следующий за ним код.",
            "14.9 Оператор defer откладывает выполнение определенного в его теле кода до момента выхода из области видимости, в которой он был использован (например, после окончания выполнения функции)."
        ]
        
    ]
}

